% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tmod_browser.R
\name{tmodBrowserTableUI}
\alias{tmodBrowserTableUI}
\alias{tmodBrowserTableServer}
\title{Shiny Module – tmod results browser table selection}
\usage{
tmodBrowserTableUI(id, cntr_titles, upset_pane = FALSE)

tmodBrowserTableServer(
  id,
  tmod_res,
  gs_id = NULL,
  multilevel = FALSE,
  tmod_dbs = NULL
)
}
\arguments{
\item{id}{identifier for the namespace of the module}

\item{cntr_titles}{possibly named character vector with contrast names}

\item{upset_pane}{if TRUE, UI for the upset plot will be created}

\item{tmod_res}{results of tmod analysis. It is a list of lists of lists
of data frames. See Details.}

\item{gs_id}{a list of reactive values (returned by \code{\link[shiny:reactiveValues]{shiny::reactiveValues()}}), including
dataset (\code{ds}), gene set ID (\code{id}), contrast id (\code{cntr}), database ID
(\code{db}) and sorting mode (\code{sort}). If \code{mod_id} is not \code{NULL}, these
reactive values will be populated, possibly triggering an action in
another shiny module.}

\item{multilevel}{if TRUE, the results are grouped in data sets}

\item{tmod_dbs}{(optional) list of tmod database objects (or lists
of list of tmod database object in multi data set mode). If NULL, upset
plots cannot be generated. See Details.}
}
\description{
Shiny Module – tmod results browser table selection
}
\details{
Regarding required data, this is probably the most complex module. That
is due to the complexity of gene set enrichment analysis – we can test
gene set enrichment using different parameters (e.g. gene list sorting order), for
different gene set collections (such as KEGG or Hallmark from MSigDB)
and, of course, for different contrast.

This module is adapted to gene set enrichment testing using the tmod
package (described in Zyla et al. 2019).
}
\section{Use of tmod database objects}{

For gene set enrichments, collections (databases) of gene sets must be
defined. Such gene set collections include KEGG and REACTOME pathways,
Gene Ontologies, transcriptional modules as well as meta-collections
such as MSigDB.

There are many ways of storing such gene set collections. One way that I
find convenient (since I programmed it myself) is included in the
gene set enrichment testing package \code{tmod}. Tmod database objects are
lists with at least three elements: \code{gs}, \code{gv} and \code{gv2gs} (see
details in the tmod package). They can be conveniently created using
the tmod package.

In 'bioshmods', these objects are included in a structure which provides
gene set information to the 'bioshmods' functions. Each such structure
is a named list with one element per gene set collection (i.e., if you
have gene set enrichment results for KEGG and REACTOME, you will have
two such elements). Each of these element is a tmod database object
(returned, for example, by the \code{\link[tmod:tmodGS-class]{tmod::makeTmod()}} function from the 'tmod'
package). See the example dataset \link{C19_gs}.
}

\section{Gene set enrichment analysis results}{

This object needs to be a hierarchical lists of lists of lists. Top list
is a named list, with each element corresponding to one contrast. On the
next level, there is a named element for each gene set collection (see
'Use of tmod objects'). Finally, there may be different sorting options
(if in doubt, use \code{pval} as the only element). The lowest level are data
frames containing column 'ID', 'Title', 'AUC', 'P.Value' and 'adj.P.Val'
as returned by e.g. \code{\link[tmod:tmodUtest]{tmod::tmodCERNOtest()}}.
}

\examples{
## Building an example from scratch
data(C19)
data(C19_gs)

db <- C19_gs$tmod_dbs$tmod

ds_res <- C19$contrasts$COVID19_ID0

ds_res <- ds_res[ order(ds_res$pvalue), ]

library(tmod)
tmod_res <- tmodCERNOtest(ds_res$symbol, mset=db)

# sorting by p-value
tmod_res <- list(pval=tmod_res)

# for datbase tmod
tmod_res <- list(tmod=tmod_res)

# for contrast Covid
tmod_res <- list(Covid=tmod_res)

if(interactive()) {

  ui <- fluidPage(tmodBrowserTableUI("tt", names(tmod_res)))
  server <- function(input, output) {
    tmodBrowserTableServer("tt", tmod_res)
  }
  shinyApp(ui, server)

}

## the data sets in `bioshmods` are preformatted, so we can use them
## directly.

if(interactive()) {

  ui <- fluidPage(tmodBrowserTableUI("tt", names(C19_gs$tmod_res), upset=TRUE))
  server <- function(input, output) {
    tmodBrowserTableServer("tt", C19_gs$tmod_res, gs_id = NULL,
                                 tmod_dbs = C19_gs$tmod_dbs)
  }
  shinyApp(ui, server)

}

}
